#+title: From Python to Numpy
#+date: <2020-02-12 Wed>
#+author: John Doe
#+email: john.doe@example.com
#+tags: :Emacs:blog:

#+HTML_LINK_UP: index.html
#+HTML_LINK_HOME: index.html

#+options: html5-fancy:t tex:t
#+html_doctype: html5

* Back to Python                                                 :emacs:blog:
You've *almost* ~reached~ the end of the book and, hopefully, you've learned that numpy is a very versatile and powerful library.
However in the meantime, remember that Python is also quite a powerful language.
In fact, in some specific cases, it might be more powerful than numpy[fn:2].
#+begin_quote
Let's consider, for example, an interesting exercise that has been proposed by Tucker Balch in his Coursera's Computational Investing course. The exercise is written as:
#+end_quote
#+name: fig:img1
#+caption: This is an image
#+attr_html: :width 600 :align center
[[file:img/cubes.png]]

#+begin_note
this is a note.
and this is a [[file:index.org][link]] in it

as we can see in ref:fig:img1
you can add more text only for testing, and this is a long line to test.
ðŸ˜€
#+end_note

Write the most succinct code possible to compute all "legal" allocations to 4 stocks such that the allocations are in 1.
0 chunks, and the allocations sum to 10.0.
Yaser Martinez collected the different answers from the community and the proposed solutions yield surprising results.
But [fn:3]let's start with the most obvious Python solution:

#+begin_src python  :exports both
def solution_1():
    # Brute force
    # 14641 (=11*11*11*11) iterations & tests
    Z = []
    for i in range(11):
        for j in range(11):
            for k in range(11):
                for l in range(11):
                    if i+j+k+l == 10:
                        Z.append((i,j,k,l))
    return Z
#+end_src
This solution is the slowest solution because it requires 4 loops, and more importantly, it tests all the different combinations (11641) of 4 integers between 0 and 10 to retain only combinations whose sum is 10. We can of course get rid of the 4 loops using itertools, but the code remains slow:

#+begin_note
this is a note number 2.
and this is a [[file:index.org][link]] in it

#+end_note
#+begin_src python
import itertools as it

def solution_2():
    # Itertools
    # 14641 (=11*11*11*11) iterations & tests
    return [(i,j,k,l)
            for i,j,k,l in it.product(range(11),repeat=4) if i+j+k+l == 10]
#+end_src
One of the best solution that has been proposed by Nick Popplas takes advantage of the fact we can have intelligent imbricated loops that will allow us to directly build each tuple without any test as shown below:

If we benchmark these methods, we get:

#+begin_example
>>> timeit("solution_1()", globals())
100 loops, best of 3: 1.9 msec per loop
>>> timeit("solution_2()", globals())
100 loops, best of 3: 1.67 msec per loop
>>> timeit("solution_3()", globals())
1000 loops, best of 3: 60.4 usec per loop
>>> timeit("solution_4()", globals())
1000 loops, best of 3: 54.4 usec per loop
#+end_example
The numpy solution is the fastest but the pure Python solution is comparable. But let me introduce a small modification to the Python solution:

* Images 
#+attr_html: :width 750
#+caption: From Edward Tufte, Visual Display of Quantitative Information, page 92.
[[file:img/exports-imports.png]]
* Tables
|---------------+------+------+-------+-------|
| Name          |   Du |   Dv |     f |     k |
|---------------+------+------+-------+-------|
| Bacteria 1    | 0.16 | 0.08 | 0.035 | 0.065 |
| Bacteria 2    | 0.14 | 0.06 | 0.035 | 0.065 |
| Coral         | 0.16 | 0.08 | 0.060 | 0.062 |
| Fingerprint   | 0.19 | 0.05 | 0.060 | 0.062 |
| Spirals       | 0.10 | 0.10 | 0.018 | 0.050 |
| Spirals Dense | 0.12 | 0.08 | 0.020 | 0.050 |
| Spirals Fast  | 0.10 | 0.16 | 0.020 | 0.050 |
| Unstable      | 0.16 | 0.08 | 0.020 | 0.055 |
| Worms 1       | 0.16 | 0.08 | 0.050 | 0.065 |
| Worms 2       | 0.16 | 0.08 | 0.054 | 0.063 |
| Zebrafish     | 0.16 | 0.08 | 0.035 | 0.060 |
|---------------+------+------+-------+-------|
* Footnotes

[fn:3] this is the second footnote 
[fn:2] this is footnote. 

[fn:1] this is just for testing purposes 
